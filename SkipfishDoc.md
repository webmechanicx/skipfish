# skipfish - web application security scanner #

  * Written and maintained by: <[Michal Zalewski](mailto:lcamtuf@google.com)>, <[Niels Heinen](mailto:heinenn@google.com)> and  <[Sebastian Roschke](mailto:s.roschke@googlemail.com)>
  * Copyright 2009 - 2012 Google Inc, rights reserved.
  * Released under terms and conditions of the Apache License, version 2.0.

## What is skipfish? ##

_Skipfish_ is an active web application security reconnaissance tool. It prepares an [interactive sitemap](http://skipfish.googlecode.com/files/skipfish-screen.png) for the targeted site by carrying out a recursive crawl and dictionary-based probes. The resulting map is then annotated with the output from a number of active (but hopefully non-disruptive) security checks. The final report generated by the tool is meant to serve as a foundation for professional web application security assessments.

## Why should I bother with this particular tool? ##

A number of commercial and open source tools with analogous functionality is readily available (e.g., [Nikto](http://cirt.net/nikto2), [Websecurify](http://www.websecurify.com/), [Netsparker](http://www.mavitunasecurity.com/), [w3af](http://w3af.sourceforge.net/), [Arachni](https://github.com/Zapotek/arachni)); stick to the one that suits you best. That said, _skipfish_ tries to address some of the common problems associated with web security scanners. Specific advantages include:

  * **High performance:** 500+ requests per second against responsive Internet targets, 2000+ requests per second on LAN / MAN networks, and 7000+ requests against local instances have been observed, with a very modest CPU, network, and memory footprint. This can be attributed to:<p>
<ul><li>Multiplexing single-thread, fully asynchronous network I/O and data processing model that eliminates memory management, scheduling, and IPC inefficiencies present in some multi-threaded clients.<p>
</li><li>Advanced HTTP/1.1 features such as range requests, content compression, and keep-alive connections, as well as forced response size limiting, to keep network-level overhead in check.<p>
</li><li>Smart response caching and advanced server behavior heuristics are used to minimize unnecessary traffic.<p>
</li><li>Performance-oriented, pure C implementation, including a custom HTTP stack.</li></ul></li></ul>

<ul><li><b>Ease of use:</b> <i>skipfish</i> is highly adaptive and reliable. The scanner features:<p>
<ul><li>Heuristic recognition of obscure path- and query-based parameter handling schemes.<p>
</li><li>Graceful handling of multi-framework sites where certain paths obey a completely different semantics, or are subject to different filtering rules.<p>
</li><li>Automatic wordlist construction based on site content analysis.<p>
</li><li>Probabilistic scanning features to allow periodic, time-bound assessments of arbitrarily complex sites.</li></ul></li></ul>

<ul><li><b>Well-designed security checks:</b>  the tool is meant to provide accurate and meaningful results:<p>
<ul><li>Handcrafted dictionaries offer excellent coverage and permit thorough <code>$keyword.$extension</code> testing in a reasonable timeframe.<p>
</li><li>Three-step differential probes are preferred to signature checks for detecting vulnerabilities.<p>
</li><li><a href='http://code.google.com/p/ratproxy'>Ratproxy</a>-style logic is used to spot subtle security problems: cross-site request forgery, cross-site script inclusion, mixed content, issues MIME- and charset mismatches, incorrect caching directives, etc.<p>
</li><li>Bundled security checks are designed to handle tricky scenarios: stored XSS (path, parameters, headers), blind SQL or XML injection, or blind shell injection.<p>
</li><li>Report post-processing drastically reduces the noise caused by any remaining false positives or server gimmicks by identifying repetitive patterns.</li></ul></li></ul>

That said, <i>skipfish</i> is not a silver bullet, and may be unsuitable for certain purposes. For example, it does not satisfy most of the requirements outlined in <a href='http://projects.webappsec.org/Web-Application-Security-Scanner-Evaluation-Criteria'>WASC Web Application Security Scanner Evaluation Criteria</a> (some of them on purpose, some out of necessity); and unlike most other projects of this type, it does not come with an extensive database of known vulnerabilities for banner-type checks.<br>
<br>
<h2>Most curious! What specific tests are implemented?</h2>

A rough list of the security checks offered by the tool is outlined below.<br>
<br>
<ul><li>High risk flaws (potentially leading to system compromise):<p>
<ul><li>Server-side SQL / PHP injection (including blind vectors, numerical parameters).<br>
</li><li>Explicit SQL-like syntax in GET or POST parameters.<br>
</li><li>Server-side shell command injection (including blind vectors).<br>
</li><li>Server-side XML / XPath injection (including blind vectors).<br>
</li><li>Format string vulnerabilities.<br>
</li><li>Integer overflow vulnerabilities.<br>
</li><li>Locations accepting HTTP PUT.</li></ul></li></ul>

<ul><li>Medium risk flaws (potentially leading to data compromise):<p>
<ul><li>Stored and reflected XSS vectors in document body (minimal JS XSS support present).<br>
</li><li>Stored and reflected XSS vectors via HTTP redirects.<br>
</li><li>Stored and reflected XSS vectors via HTTP header splitting.<br>
</li><li>Directory traversal / file inclusion (including constrained vectors).<br>
</li><li>Assorted file POIs (server-side sources, configs, etc).<br>
</li><li>Attacker-supplied script and CSS inclusion vectors (stored and reflected).<br>
</li><li>External untrusted script and CSS inclusion vectors.<br>
</li><li>Mixed content problems on script and CSS resources (optional).<br>
</li><li>Password forms submitting from or to non-SSL pages (optional).<br>
</li><li>Incorrect or missing MIME types on renderables.<br>
</li><li>Generic MIME types on renderables.<br>
</li><li>Incorrect or missing charsets on renderables.<br>
</li><li>Conflicting MIME / charset info on renderables.<br>
</li><li>Bad caching directives on cookie setting responses.</li></ul></li></ul>

<ul><li>Low risk issues (limited impact or low specificity):<p>
<ul><li>Directory listing bypass vectors.<br>
</li><li>Redirection to attacker-supplied URLs (stored and reflected).<br>
</li><li>Attacker-supplied embedded content (stored and reflected).<br>
</li><li>External untrusted embedded content.<br>
</li><li>Mixed content on non-scriptable subresources (optional).<br>
</li><li>HTTPS -> HTTP submission of HTML forms (optional).<br>
</li><li>HTTP credentials in URLs.<br>
</li><li>Expired or not-yet-valid SSL certificates.<br>
</li><li>HTML forms with no XSRF protection.<br>
</li><li>Self-signed SSL certificates.<br>
</li><li>SSL certificate host name mismatches.<br>
</li><li>Bad caching directives on less sensitive content.</li></ul></li></ul>

<ul><li>Internal warnings:<p>
<ul><li>Failed resource fetch attempts.<br>
</li><li>Exceeded crawl limits.<br>
</li><li>Failed 404 behavior checks.<br>
</li><li>IPS filtering detected.<br>
</li><li>Unexpected response variations.<br>
</li><li>Seemingly misclassified crawl nodes.</li></ul></li></ul>

<ul><li>Non-specific informational entries:<p>
<ul><li>General SSL certificate information.<br>
</li><li>Significantly changing HTTP cookies.<br>
</li><li>Changing <code>Server</code>, <code>Via</code>, or <code>X-...</code> headers.<br>
</li><li>New 404 signatures.<br>
</li><li>Resources that cannot be accessed.<br>
</li><li>Resources requiring HTTP authentication.<br>
</li><li>Broken links.<br>
</li><li>Server errors.<br>
</li><li>All external links not classified otherwise (optional).<br>
</li><li>All external e-mails (optional).<br>
</li><li>All external URL redirectors (optional).<br>
</li><li>Links to unknown protocols.<br>
</li><li>Form fields that could not be autocompleted.<br>
</li><li>Password entry forms (for external brute-force).<br>
</li><li>File upload forms.<br>
</li><li>Other HTML forms (not classified otherwise).<br>
</li><li>Numerical file names (for external brute-force).<br>
</li><li>User-supplied links otherwise rendered on a page.<br>
</li><li>Incorrect or missing MIME type on less significant content.<br>
</li><li>Generic MIME type on less significant content.<br>
</li><li>Incorrect or missing charset on less significant content.<br>
</li><li>Conflicting MIME / charset information on less significant content.<br>
</li><li>OGNL-like parameter passing conventions.</li></ul></li></ul>

Along with a list of identified issues, <i>skipfish</i> also provides summary overviews of document types and issue types found; and an interactive sitemap, with nodes discovered through brute-force denoted in a distinctive way.<br>
<br>
<b>NOTE:</b> As a conscious design decision, <i>skipfish</i> will not redundantly complain about highly non-specific or no-impact issues, including but not limited to:<br>
<br>
<ul><li>Non-<code>httponly</code> or non-<code>secure</code> cookies,<br>
</li><li>Non-HTTPS or <code>autocomplete</code>-enabled forms,<br>
</li><li>HTML comments detected on a page,<br>
</li><li>Filesystem path or internal IP disclosure in error messages,<br>
</li><li>Server or framework version disclosure,<br>
</li><li>Servers supporting <code>TRACE</code> or <code>OPTIONS</code> requests,<br>
</li><li>Mere presence of certain technologies, such as WebDAV.</li></ul>

Most of these aspects are easy to inspect in a report if so desired - for example, all the HTML forms and password forms are listed separately, so are new cookies or interesting HTTP headers - and the expectation is that the auditor may opt to make certain design recommendations based on this data where appropriate.<br>
<br>
<h2>All right, I want to try it out. What do I need to know?</h2>

<b>First and foremost, please do not be evil. Use <i>skipfish</i> only against services you own, or have a permission to test.</b>

Keep in mind that all types of security testing can be disruptive. Although the scanner is designed not to carry out malicious attacks, it may accidentally interfere with the operations of the site. You must accept the risk, and plan accordingly. Run the scanner against test instances where feasible, and be prepared to deal with the consequences if things go wrong.<br>
<br>
Also note that the tool is meant to be used by security professionals, and is experimental in nature. It may return false positives or miss obvious security problems - and even when it operates perfectly, it is simply not meant to be a point-and-click application. Do not take its output at face value.<br>
<br>
Running the tool against vendor-supplied demo sites is not a good way to evaluate it, as they usually approximate vulnerabilities <a href='http://zero.webappsecurity.com/rootlogin.asp.bak'>very imperfectly</a>; we made no effort to accommodate these cases.<br>
<br>
Lastly, the scanner is simply not designed for dealing with rogue and misbehaving HTTP servers - and offers no guarantees of safe (or sane) behavior there.<br>
<br>
<h2>How to run the scanner?</h2>

To compile it, simply unpack the archive and try <code>make</code>. Chances are, you will need to install <a href='http://ftp.gnu.org/gnu/libidn/libidn-1.18.tar.gz'>libidn</a> or <a href='http://www.pcre.org/'>libpcre3</a> first.<br>
<br>
Next, you need to read the instructions provided in doc/dictionaries.txt to select the right dictionary file and configure it correctly. This step has a profound impact on the quality of scan results later on, so don't skip it.<br>
<br>
Once you have the dictionary selected, you can use -S to load that dictionary,<br>
and -W to specify an initially empty file for any newly learned site-specific<br>
keywords (which will come handy in future assessments):<br>
<br>
<pre><code>$ touch new_dict.wl<br>
$ ./skipfish -o output_dir -S existing_dictionary.wl -W new_dict.wl \<br>
  http://www.example.com/some/starting/path.txt<br>
</code></pre>

You can use -W- if you don't want to store auto-learned keywords anywhere.<br>
<br>
Note that you can provide more than one starting URL if so desired; all of them will be crawled. You can also read a list of URLs from a file using this syntax:<br>
<br>
<pre><code>$ ./skipfish ...other options...  -o output_dir @/path/to/url_list.txt<br>
</code></pre>

The tool will display some helpful stats while the scan is in progress. You<br>
can also switch to a list of in-flight HTTP requests by pressing return.<br>
<br>
In the example above, <i>skipfish</i> will scan the entire <code>www.example.com</code> (including services on other ports, if linked to from the main page), and write a report to <code>output_dir/index.html</code>. You can then view this report with your favorite browser (Java<b></b>Script must be enabled; and because of recent <code>file:///</code> security improvements in certain browsers, you might need to access results over HTTP). The <code>index.html</code> file is static; actual results are stored as a hierarchy of JSON files, suitable for machine processing or different presentation frontends if needs be. A text-based list of all the visited URLs, plus some useful metadata, is stored to a file named <code>pivots.txt</code>, too.<br>
<br>
A simple companion script, <code>sfscandiff</code>, can be used to compute a delta for two scans executed against the same target with the same flags. The newer report will be non-destructively annotated by adding red background to all new or changed nodes; and blue  background to all new or changed issues found.<br>
<br>
Some sites may require authentication; for simple HTTP credentials, you can try:<br>
<br>
<pre><code>$ ./skipfish -A user:pass ...other parameters...<br>
</code></pre>

Alternatively, if the site relies on HTTP cookies instead, log in in your browser or using<br>
a simple <code>curl</code> script, and then provide <i>skipfish</i> with a session cookie:<br>
<br>
<pre><code>$ ./skipfish -C name=val ...other parameters...<br>
</code></pre>

Other session cookies may be passed the same way, one per each <code>-C</code> option.<br>
<br>
Certain URLs on the site may log out your session; you can combat this in two ways: by using the <code>-N</code> option, which causes the scanner to reject attempts to set or delete cookies; or with the <code>-X</code> parameter, which prevents matching URLs from being fetched:<br>
<br>
<pre><code>$ ./skipfish -X /logout/logout.aspx ...other parameters...<br>
</code></pre>

The <code>-X</code> option is also useful for speeding up your scans by excluding <code>/icons/</code>, <code>/doc/</code>,<br>
<code>/manuals/</code>, and other standard, mundane locations along these lines. In general, you can<br>
use <code>-X</code> and <code>-I</code> (only spider URLs matching a substring) to limit the scope of a scan any way you like - including restricting it only to a specific protocol and port:<br>
<br>
<pre><code>$ ./skipfish -I http://example.com:1234/ ...other parameters...<br>
</code></pre>

A related function, -K, allows you to specify parameter names not to fuzz<br>
(useful for applications that put session IDs in the URL, to minimize noise).<br>
<br>
Another useful scoping option is <code>-D</code> - allowing you to specify additional hosts or domains to consider in-scope for the test. By default, all hosts appearing in the command-line URLs are added to the list - but you can use <code>-D</code> to broaden these rules, for example:<br>
<br>
<pre><code>$ ./skipfish -D test2.example.com -o output-dir http://test1.example.com/<br>
</code></pre>

...or, for a domain wildcard match, use:<br>
<br>
<pre><code>$ ./skipfish -D .example.com -o output-dir http://test1.example.com/<br>
</code></pre>

In some cases, you do not want to actually crawl a third-party domain, but you trust the owner of that domain enough not to worry about cross-domain content inclusion from that location. To suppress warnings, you can use the <code>-B</code> option, for example:<br>
<br>
<pre><code>$ ./skipfish -B .google-analytics.com -B .googleapis.com ...other parameters...<br>
</code></pre>

By default, <i>skipfish</i> sends minimalistic HTTP headers to reduce the amount of data exchanged over the wire; some sites examine <code>User-Agent</code> strings or header ordering to reject unsupported clients, however. In such a case, you can use <code>-b ie</code> or <code>-b ffox</code> to mimic one of the two popular browsers; and <code>-b phone</code> to mimic iPhone.<br>
<br>
When it comes to customizing your HTTP requests, you can also use the <code>-H</code> option to insert any additional, non-standard headers (including an arbitrary <code>User-Agent</code> value); or <code>-F</code> to define a custom mapping between a host and an IP (bypassing the resolver). The latter feature is particularly useful for not-yet-launched or legacy services.<br>
<br>
Some sites may be too big to scan in a reasonable timeframe. If the site features well-defined tarpits - for example, 100,000 nearly identical user profiles as a part of a social network - these specific locations can be excluded with <code>-X</code> or <code>-S</code>.  In other cases, you may need to resort to other settings: <code>-d</code> limits crawl depth to a specified number of subdirectories; <code>-c</code> limits the number of children per directory, <code>-x</code> limits the total number of descendants per crawl tree branch; and <code>-r</code> limits the total number of requests to send in a scan.<br>
<br>
An interesting option is available for repeated assessments: <code>-p</code>. By specifying a percentage between 1 and 100%, it is possible to tell the crawler to follow fewer than 100% of all links, and try fewer than 100% of all dictionary entries. This - naturally - limits the completeness of a scan, but unlike most other settings, it does so in a balanced, non-deterministic manner. It is extremely useful when you are setting up time-bound, but periodic assessments of your infrastructure. Another related option is <code>-q</code>, which sets the initial random seed for the crawler to a specified value. This can be used to exactly reproduce a previous scan to compare results. Randomness is relied upon most heavily in the <code>-p</code> mode, but also for making a couple of other scan management decisions elsewhere.<br>
<br>
Some particularly complex (or broken) services may involve a very high number of identical or nearly identical pages. Although these occurrences are by default grayed out in the report, they still use up some screen estate and take a while to process on Java<b></b>Script level. In such extreme cases, you may use the <code>-Q</code> option to suppress reporting of duplicate nodes altogether, before the report is written. This may give you a less comprehensive understanding of how the site is organized, but has no impact on test coverage.<br>
<br>
In certain quick assessments, you might also have no interest in paying any particular attention to the desired functionality of the site - hoping to explore non-linked secrets only. In such a case, you may specify <code>-P</code> to inhibit all HTML parsing. This limits the coverage and takes away the ability for the scanner to learn new keywords by looking at the HTML, but speeds up the test dramatically. Another similarly crippling option that reduces the risk of persistent effects of a scan is <code>-O</code>, which inhibits all form parsing<br>
and submission steps.<br>
<br>
Some sites that handle sensitive user data care about SSL - and about getting it right. <i>Skipfish</i> may optionally assist you in figuring out problematic mixed content or password submission scenarios - use the <code>-M</code> option to enable this. The scanner will complain about situations such as <code>http://</code> scripts being loaded on <code>https://</code> pages - but will disregard non-risk scenarios such as images.<br>
<br>
Likewise, certain pedantic sites may care about cases where caching is restricted on HTTP/1.1 level, but no explicit HTTP/1.0 caching directive is given on specifying <code>-E</code> in the command-line causes skipfish to log all such cases carefully.<br>
<br>
In some occasions, you want to limit the requests per second to limit the load on the targets server (or possibly bypass DoS protection). The -l flag can be used to set this limit and the value given is the maximum amount of requests per second you want skipfish to perform.<br>
<br>
Scans typically should not take weeks. In many cases, you probably want to limit the scan duration so that it fits within a certain time window. This can be done with the -k flag, which allows the amount of hours, minutes and seconds to be specified in a H:M:S format. Use of<br>
this flag can affect the scan coverage if the scan timeout occurs before testing all pages.<br>
<br>
Lastly, in some assessments that involve self-contained sites without extensive user content, the auditor may care about any external e-mails or HTTP links seen, even if they have no immediate security impact. Use the <code>-U</code> option to have these logged.<br>
<br>
Dictionary management is a special topic, and - as mentioned - is covered in more detail in <code>dictionaries/README-FIRST</code>. Please read that file before proceeding. Some of the relevant options include -S and -W (covered earlier), -L to suppress auto-learning, -G to limit the keyword guess jar size, -R to drop old dictionary entries, and -Y to inhibit expensive $keyword.$extension fuzzing.<br>
<br>
<i>Skipfish</i> also features a form auto-completion mechanism in order to maximize scan coverage. The values should be non-malicious, as they are not meant to implement security checks - but rather, to get past input validation logic. You can define additional rules, or override existing ones, with the <code>-T</code> option (<code>-T form_field_name=field_value</code>, e.g. <code>-T login=test123 -T password=test321</code> - although note that <code>-C</code> and <code>-A</code> are a much better method of logging in).<br>
<br>
There is also a handful of performance-related options. Use <code>-g</code> to set the maximum number of connections to maintain, globally, to all targets (it is sensible to keep this under 50 or so to avoid overwhelming the TCP/IP stack on your system or on the nearby NAT / firewall devices); and <code>-m</code> to set the per-IP limit (experiment a bit: 2-4 is usually good for localhost, 4-8 for local networks, 10-20 for external targets, 30+ for really lagged or non-keep-alive hosts). You can also use <code>-w</code> to set the I/O timeout (i.e., <i>skipfish</i>
will wait only so long for an individual read or write), and <code>-t</code> to set the total request timeout, to account for really slow or really fast sites.<br>
<br>
Lastly, <code>-f</code> controls the maximum number of consecutive HTTP errors you are willing to see before aborting the scan; and <code>-s</code> sets the maximum length of a response to fetch and parse (longer responses will be truncated).<br>
<br>
When scanning large, multimedia-heavy sites, you may also want to specify <code>-e</code>. This prevents binary documents from being kept in memory for reporting purposes, freeing up a lot of RAM.<br>
<br>
Further rate-limiting is available through third-party user mode tools such as <a href='http://monkey.org/~marius/trickle/'>trickle</a>, or kernel-level traffic shaping.<br>
<br>
Oh, and real-time scan statistics can be suppressed with <code>-u</code>.<br>
<br>
<h2>But seriously, how to run it?</h2>

A standard, authenticated scan of a well-designed and self-contained site (warns about all external links, e-mails, mixed content, and caching header issues), including gentle brute-force:<br>
<br>
<pre><code>$ touch new_dict.wl<br>
$ ./skipfish -MEU -S dictionaries/minimal.wl -W new_dict.wl \<br>
    -C "AuthCookie=value" -X /logout.aspx -o output_dir \<br>
   http://www.example.com/<br>
</code></pre>

Five-connection crawl, but no brute-force; pretending to be MSIE and caring less about ambiguous MIME or character set mismatches, and trusting example.com links:<br>
<br>
<pre><code>$ ./skipfish -m 5 -L -W- -o output_dir -b ie -B example.com http://www.example.com/<br>
</code></pre>

Heavy brute force only (no HTML link extraction), limited to a single directory and timing out after 5 seconds:<br>
<br>
<pre><code>$ touch new_dict.wl<br>
$ ./skipfish -S dictionaries/complete.wl -W new_dict.wl -P -I http://www.example.com/dir1/ \ <br>
   -o output_dir -t 5 -I  http://www.example.com/dir1/<br>
</code></pre>

For a short list of all command-line options, try <code>./skipfish -h</code>. A quick primer on some of the particularly useful options is also <a href='http://lcamtuf.blogspot.com/2010/11/understanding-and-using-skipfish.html'>given here</a>.<br>
<br>
<h2>How to interpret and address the issues reported?</h2>

Most of the problems reported by <i>skipfish</i> should self-explanatory, assuming you have a good gasp of the fundamentals of web security. If you need a quick refresher on some of the more complicated topics, such as MIME sniffing, you may enjoy our comprehensive <a href='http://code.google.com/p/browsersec/wiki/Main'>Browser Security Handbook</a> as a starting point.<br>
<br>
If you still need assistance, there are several organizations that put a considerable effort into documenting and explaining many of the common web security threats, and advising the public on how to address them. I encourage you to refer to the materials published by OWASP and Web Application Security Consortium, amongst others:<br>
<br>
<ul><li><a href='http://www.owasp.org/index.php/Category:Principle'>OWASP Engineering principles</a>
</li><li><a href='http://www.owasp.org/index.php/Category:OWASP_Guide_Project'>OWASP guidelines</a>
</li><li><a href='http://www.webappsec.org/projects/articles/'>WASC article library</a></li></ul>

Although I am happy to diagnose problems with the scanner itself, I regrettably cannot offer any assistance with the inner workings of third-party web applications.<br>
<br>
<h2>Known limitations / feature wishlist</h2>

Below is a list of features currently missing in <i>skipfish</i>. If you wish to improve the tool by contributing code in one of these areas, please let me know:<br>
<br>
<ul><li>Buffer overflow checks: after careful consideration, I suspect there is no reliable way to test for buffer overflows remotely. Much like the actual fault condition we are looking for, proper buffer size checks may also result in uncaught exceptions, 500 messages, etc. I would love to be proved wrong, though.</li></ul>

<ul><li>Fully-fledged Java<b></b>Script XSS detection: several rudimentary checks are present in the code, but there is no proper script engine to evaluate expressions and DOM access built in.</li></ul>

<ul><li>Variable length encoding character consumption / injection bugs: these problems seem to be largely addressed on browser level at this point, so they were much lower priority at the time of this writing.</li></ul>

<ul><li>Security checks and link extraction for third-party, plugin-based content (Flash, Java, PDF, etc).</li></ul>

<ul><li>Password brute-force and numerical filename brute-force probes.</li></ul>

<ul><li>Search engine integration (vhosts, starting paths).</li></ul>

<ul><li>VIEWSTATE decoding.</li></ul>

<ul><li>NTLM and digest authentication.</li></ul>

<ul><li>More specific PHP tests (eval injection, RFI - although this is usually picked up by existing SQL and traversal checks).</li></ul>

<ul><li>HTTP proxy support: an experimental HTTP proxy support is available through a directive in config.h. Adding support for HTTPS proxying is more complicated, and still in the works.</li></ul>

<ul><li>SOCKS proxy support: you may have luck with <a href='http://tsocks.sourceforge.net/'>tsocks</a> for this purpose, though.</li></ul>

<ul><li>Scan resume option.</li></ul>

<ul><li>Standalone installation (<code>make install</code>) support.</li></ul>

<ul><li>A database for banner / version checks?</li></ul>

<h2>Oy! Something went horribly wrong!</h2>

There is no web crawler so good that there wouldn't be a web framework to one day set it on fire. If you encounter what appears to be bad behavior (e.g., a scan that takes forever and generates too many requests, completely bogus nodes in scan output, or outright crashes), please first check our <a href='http://code.google.com/p/skipfish/wiki/KnownIssues'>known issues page</a>. If you can't find a satisfactory answer there, recompile the scanner with:<br>
<br>
<pre><code>$ make clean debug<br>
</code></pre>

...and re-run it this way:<br>
<br>
<pre><code>$ ./skipfish [...previous options...] 2&gt;logfile.txt<br>
</code></pre>

You can then inspect <code>logfile.txt</code> to get an idea what went wrong; if it looks like a scanner problem, please scrub any sensitive information from the log file and send it to the author.<br>
<br>
If the scanner crashed, please recompile it as indicated above, and then type:<br>
<br>
<pre><code>$ ulimit -c unlimited<br>
$ ./skipfish [...previous options...] 2&gt;logfile.txt<br>
$ gdb --batch -ex back ./skipfish core<br>
</code></pre>

...and be sure to send the author the output of that last command as well.<br>
<br>
<h2>Credits and feedback</h2>

<i>Skipfish</i> is made possible thanks to the contributions of, and valuable feedback from, Google's information security engineering team.<br>
<br>
If you have any bug reports, questions, suggestions, or concerns regarding the application, don't hesitate to ping the authors per email (or <a href='http://code.google.com/p/skipfish/issues/list'>issue tracker</a>).